[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Digital Archaeology Maintainathon",
    "section": "",
    "text": "A README is a plaintext file that includes a detailed description of a project. It’s typically located in the root directory, and often includes:\n\nA broad overview of what the project does, why it was made, and the rationale behind the way it was implemented\nInstructions for how to install or run the code\nLinks to other related tools or resources\nRecognition of various contributors\nStatus updates, feature roadmaps, and an overview of the project’s overall orientation\n\nmakeareadme.com is a great resource that provides advice for writing clear and helpful readmes, including a template that you may adapt for your own purposes.\n\n\n\nCode comments appear as silent (i.e. non-functional) text embedded in the source code. They communicate what functions do by providing a brief description of how they are situated in broader workflows. They may also include notes and task lists for iteratively improving existing functions.\nSome qualities of good code comments include:\n\n\nClear and concise\nEasy to remove once a fix has been implemented\nExplain the “why”, not the “what”\nWritten for your future self\n\n\nHere is a great write-up about how to write effective code comments: How to Write Professional Code Comments: A Beginner’s Guide to Better Code Documentation (dev.to)\nAdditionally, here are some great examples of code comments written by archaeologists:\n\nSingle-lineMulti-lineDocumentationInlineTODO\n\n\nFrom Joe Roe’s paleoclim:\n# Download\nif (!fs::file_exists(tmpfile) | isTRUE(skip_cache)) {\n  raster &lt;- download_paleoclim(url, tmpfile, as, quiet)\n}\n\n\nFrom Joe Roe’s paleoclim:\n#' Load data from PaleoClim\n#'\n#' Loads a PaleoClim data file (`.zip` format) into R as a `SpatRaster`.\n#'\n#' @param file Character. Path to a *.zip file downloaded from PaleoClim.\n#' @param as          Character. `as = \"raster\"` returns a `RasterStack` object\n#'                    (see [raster::stack()]) instead of the default raster from\n#'                    the `terra` package. It is provided for backwards\n#'                    compatibility and will be removed in future versions.\n#'                    Requires the `raster` package.\n#'\n#' @return\n#' `SpatRaster` object (see [terra::rast()]) with each bioclimatic variable\n#' as a separate named layer.\n#'\n#' @export\n#'\n#' @examples\n#' file &lt;- system.file(\"testdata\", \"LH_v1_10m_cropped.zip\",\n#'                     package = \"rpaleoclim\")\n#' load_paleoclim(file)\nload_paleoclim &lt;- function(file, as = c(\"terra\", \"raster\")) {\n  as &lt;- rlang::arg_match(as)\n\n  tmpdir &lt;- fs::file_temp(\"paleoclim_\")\n  utils::unzip(file, exdir = tmpdir)\n\n  tifs &lt;- fs::dir_ls(tmpdir, recurse = TRUE, glob = \"*.tif\")\n  names(tifs) &lt;- fs::path_ext_remove(fs::path_file(tifs))\n\n  if (length(tifs) &gt; 0) raster &lt;- terra::rast(tifs)\n  else raster &lt;- terra::rast()\n\n  if (as == \"raster\" ) {\n    if (!requireNamespace(\"raster\", quietly = TRUE)) {\n      rlang::abort(\n        '`as = \"raster\"` requires package `raster`',\n        class = \"rpaleoclim_missing_package\"\n      )\n    }\n\n\nFrom Joe Roe’s paleoclim:\n#' Retrieve data from PaleoClim\n#'\n#' Downloads data from PaleoClim (&lt;http://www.paleoclim.org&gt;) and loads it into R\n#' as a `SpatRaster` object.\n#'\n#' @param period      Character. Time period to retrieve.\n#' @param resolution  Character. Resolution to retrieve.\n#' @param region      `SpatExtent` object or object that can be coerced to\n#'                    `SpatExtent` (see [terra::ext()]), describing the\n#'                    region to be retrieved. If `NULL`, defaults to the whole\n#'                    globe.\n#' @param as          Character. `as = \"raster\"` returns a `RasterStack` object\n#'                    (see [raster::stack()]) instead of the default raster from\n#'                    the `terra` package. It is provided for backwards\n#'                    compatibility and will be removed in future versions.\n#'                    Requires the `raster` package.\n#' @param skip_cache  Logical. If `TRUE`, cached data will be ignored.\n#' @param cache_path  Logical. Path to directory where downloaded files should\n#'   be saved. Defaults to R's temporary directory.\n#' @param quiet       Logical. If `TRUE`, suppresses messages and download\n#'   progress information.\n#'\n#' @details\n#' See &lt;http://www.paleoclim.org&gt; for details of the datasets and codings.\n#' Data at 30s resolution is only available for 'cur' and 'lgm'.\n#'\n#' By default, `paleoclim()` will read previously downloaded files in R's\n#' temporary directory if available. Use `skip_cache = TRUE` to override this.\n#' `cache_path` can also be set to another directory. This can be useful if you\n#' want to reuse downloaded data between sessions.\n#'\n#' @return\n#' `SpatRaster` object (see [terra::rast()]) with each bioclimatic variable\n#' as a separate named layer.\n#'\n#' @export\n#'\n#' @examplesIf interactive() && curl::has_internet()\n#' paleoclim(\"lh\", \"10m\")\n\n\n\n\n\n\n\n\n\n\n\n\nA cff file is a plaintext file with .cff extension containing information that can be picked up by a reference manager to generate clean citations. It follows a yaml format, which is both human- and machine-readable.\nSee the example below from Maddison Simon’s and Sophie Schmidt’s Percopackage for some common information to include in your cff:\ncff-version: 1.2.0\nmessage: \"If you use this software, please cite it as below.\"\nauthors:\n  - family-names: Maddison\n    given-names: M. Simon\n    orcid: https://orcid.org/0000-0001-5006-6604\n  - family-names: Schmidt\n    given-names: Sophie C.\n    orcid: https://orcid.org/0000-0003-4696-2101\ntitle: \"Percopackage\"\nversion: 0.0.0.9001\nidentifiers:\n  - type: doi\n    value: 10.17605/OSF.IO/7EXTC\ndate-released: 2024-08-24\n\n\n\n\nFor more complex software, going beyond a readme\nSphynx and other tools\nBest practices\nProvide some excellent examples"
  },
  {
    "objectID": "resources.html#documentation",
    "href": "resources.html#documentation",
    "title": "Digital Archaeology Maintainathon",
    "section": "",
    "text": "A README is a plaintext file that includes a detailed description of a project. It’s typically located in the root directory, and often includes:\n\nA broad overview of what the project does, why it was made, and the rationale behind the way it was implemented\nInstructions for how to install or run the code\nLinks to other related tools or resources\nRecognition of various contributors\nStatus updates, feature roadmaps, and an overview of the project’s overall orientation\n\nmakeareadme.com is a great resource that provides advice for writing clear and helpful readmes, including a template that you may adapt for your own purposes.\n\n\n\nCode comments appear as silent (i.e. non-functional) text embedded in the source code. They communicate what functions do by providing a brief description of how they are situated in broader workflows. They may also include notes and task lists for iteratively improving existing functions.\nSome qualities of good code comments include:\n\n\nClear and concise\nEasy to remove once a fix has been implemented\nExplain the “why”, not the “what”\nWritten for your future self\n\n\nHere is a great write-up about how to write effective code comments: How to Write Professional Code Comments: A Beginner’s Guide to Better Code Documentation (dev.to)\nAdditionally, here are some great examples of code comments written by archaeologists:\n\nSingle-lineMulti-lineDocumentationInlineTODO\n\n\nFrom Joe Roe’s paleoclim:\n# Download\nif (!fs::file_exists(tmpfile) | isTRUE(skip_cache)) {\n  raster &lt;- download_paleoclim(url, tmpfile, as, quiet)\n}\n\n\nFrom Joe Roe’s paleoclim:\n#' Load data from PaleoClim\n#'\n#' Loads a PaleoClim data file (`.zip` format) into R as a `SpatRaster`.\n#'\n#' @param file Character. Path to a *.zip file downloaded from PaleoClim.\n#' @param as          Character. `as = \"raster\"` returns a `RasterStack` object\n#'                    (see [raster::stack()]) instead of the default raster from\n#'                    the `terra` package. It is provided for backwards\n#'                    compatibility and will be removed in future versions.\n#'                    Requires the `raster` package.\n#'\n#' @return\n#' `SpatRaster` object (see [terra::rast()]) with each bioclimatic variable\n#' as a separate named layer.\n#'\n#' @export\n#'\n#' @examples\n#' file &lt;- system.file(\"testdata\", \"LH_v1_10m_cropped.zip\",\n#'                     package = \"rpaleoclim\")\n#' load_paleoclim(file)\nload_paleoclim &lt;- function(file, as = c(\"terra\", \"raster\")) {\n  as &lt;- rlang::arg_match(as)\n\n  tmpdir &lt;- fs::file_temp(\"paleoclim_\")\n  utils::unzip(file, exdir = tmpdir)\n\n  tifs &lt;- fs::dir_ls(tmpdir, recurse = TRUE, glob = \"*.tif\")\n  names(tifs) &lt;- fs::path_ext_remove(fs::path_file(tifs))\n\n  if (length(tifs) &gt; 0) raster &lt;- terra::rast(tifs)\n  else raster &lt;- terra::rast()\n\n  if (as == \"raster\" ) {\n    if (!requireNamespace(\"raster\", quietly = TRUE)) {\n      rlang::abort(\n        '`as = \"raster\"` requires package `raster`',\n        class = \"rpaleoclim_missing_package\"\n      )\n    }\n\n\nFrom Joe Roe’s paleoclim:\n#' Retrieve data from PaleoClim\n#'\n#' Downloads data from PaleoClim (&lt;http://www.paleoclim.org&gt;) and loads it into R\n#' as a `SpatRaster` object.\n#'\n#' @param period      Character. Time period to retrieve.\n#' @param resolution  Character. Resolution to retrieve.\n#' @param region      `SpatExtent` object or object that can be coerced to\n#'                    `SpatExtent` (see [terra::ext()]), describing the\n#'                    region to be retrieved. If `NULL`, defaults to the whole\n#'                    globe.\n#' @param as          Character. `as = \"raster\"` returns a `RasterStack` object\n#'                    (see [raster::stack()]) instead of the default raster from\n#'                    the `terra` package. It is provided for backwards\n#'                    compatibility and will be removed in future versions.\n#'                    Requires the `raster` package.\n#' @param skip_cache  Logical. If `TRUE`, cached data will be ignored.\n#' @param cache_path  Logical. Path to directory where downloaded files should\n#'   be saved. Defaults to R's temporary directory.\n#' @param quiet       Logical. If `TRUE`, suppresses messages and download\n#'   progress information.\n#'\n#' @details\n#' See &lt;http://www.paleoclim.org&gt; for details of the datasets and codings.\n#' Data at 30s resolution is only available for 'cur' and 'lgm'.\n#'\n#' By default, `paleoclim()` will read previously downloaded files in R's\n#' temporary directory if available. Use `skip_cache = TRUE` to override this.\n#' `cache_path` can also be set to another directory. This can be useful if you\n#' want to reuse downloaded data between sessions.\n#'\n#' @return\n#' `SpatRaster` object (see [terra::rast()]) with each bioclimatic variable\n#' as a separate named layer.\n#'\n#' @export\n#'\n#' @examplesIf interactive() && curl::has_internet()\n#' paleoclim(\"lh\", \"10m\")\n\n\n\n\n\n\n\n\n\n\n\n\nA cff file is a plaintext file with .cff extension containing information that can be picked up by a reference manager to generate clean citations. It follows a yaml format, which is both human- and machine-readable.\nSee the example below from Maddison Simon’s and Sophie Schmidt’s Percopackage for some common information to include in your cff:\ncff-version: 1.2.0\nmessage: \"If you use this software, please cite it as below.\"\nauthors:\n  - family-names: Maddison\n    given-names: M. Simon\n    orcid: https://orcid.org/0000-0001-5006-6604\n  - family-names: Schmidt\n    given-names: Sophie C.\n    orcid: https://orcid.org/0000-0003-4696-2101\ntitle: \"Percopackage\"\nversion: 0.0.0.9001\nidentifiers:\n  - type: doi\n    value: 10.17605/OSF.IO/7EXTC\ndate-released: 2024-08-24\n\n\n\n\nFor more complex software, going beyond a readme\nSphynx and other tools\nBest practices\nProvide some excellent examples"
  },
  {
    "objectID": "resources.html#longevity",
    "href": "resources.html#longevity",
    "title": "Digital Archaeology Maintainathon",
    "section": "Longevity",
    "text": "Longevity\n\nArchive your code in a long-term repository\nWhile commercial platforms like GitHub and GitLab may provide very useful collaboration features, they should not be trusted as long-term stewards of software or data. Professional archives should instead be used to backup public-facing code repositories.\nZenodo is a general-purpose open repository developed under the European OpenAIRE program and operated by CERN, which allows researchers to deposit research papers, data sets, research software, reports, and any other research related digital artefacts. One of its key features is direct integration with GitHub, and once configured, saves a snapshot of each release. For each submission, a persistent digital object identifier (DOI) is minted.\nSoftware Heritage is another archive dedicated to preserving publicly accessible code. It regularly crawls several software forges and package indexes, and anyone can upload their own repositories too.\n\n\nArchive abandoned projects\nIt may be prudent to acknowledge when it’s time to tuck a project away and mark it as archived. This will put a banner on your repo and restrict any new pull requests.\nIf a project has been picked up by others, or the work continues in another forum, make sure to provide a link in the original README!\n\n\nDevelop a release strategy\nSharing code as a series of stable releases makes it easier to share code with predictable functionality. As new features are implemented or when the codebase changes in substantial ways, the software should be rolled into a new release. This enhances clarity for what users can expect when they download a specific release. It also makes it easier to communicate and de-bug issues raised by users by ensuring that all parties are accessing the same codebase.\nThere are numerous schemes for releasing code, which enable developers to communicate the degree of changes made between versions. Some of these include:\n\nSemantic Versioning: Major, Minor or Patch versions indicate breaking changes relative to prior versions.\nAlternative Versioning (AltVer): Tracks implementation of major overhauls, new features, and careful maintenance.\nCalendar Versioning (CalVer): For “rolling” releases that follow a regular maintenance cycle."
  },
  {
    "objectID": "resources.html#productivity",
    "href": "resources.html#productivity",
    "title": "Digital Archaeology Maintainathon",
    "section": "Productivity",
    "text": "Productivity\n\nin progress: Open issues\n\nOn other projects\nOn your own projects\n\n\n\nDevelop a project roadmap\nIt may be helpful to develop a plan of action to structure future work. Some factors to consider include:\n\nWhat features are on the horizon?\nWhat steps need to be taken to achieve them?\nWhat resources will be needed to ensure effective action?\nWho can I call on for support?\n\nEffective roadmaps have tangible and measurable outcomes, and are comprised of tasks that can actually be acted upon. See this resource for some great tips on how to write great roadmaps."
  },
  {
    "objectID": "resources.html#collaboration-and-community-building",
    "href": "resources.html#collaboration-and-community-building",
    "title": "Digital Archaeology Maintainathon",
    "section": "Collaboration and Community-Building",
    "text": "Collaboration and Community-Building\n\nAdd a license\nLicenses describe legal rights for accessing, using and modifying code. Open licenses, which enable widespread and uninhibited use, are increasingly common, however copyleft or opinionated licenses impose restrictions that add conditions based on specific use-cases. For instance, CC-NC limits reuse to non-commercial applications, copyleft forces downstream applications to adopt an equally permissive license for any derivative works, and numerous other licenses are aligned with specific social causes. The Hippocratic License hosts a tool for creating a custom license, including explicit allowances and restrictions for various potential use-cases, such as a Fossil Fuel Divestment module, a Law Enforcement module, and a Supply Chain Transparency module.\nVisit choosealicense.com for an extremely detailed survey and comparison of various software and non-software licenses. There is also a page describing what happens if you don’t choose a license.\nNote that software licenses are often distinct from licenses intended for non-software materials, such as data, media, documentation and fonts.\n\n\nAcknowledge contributors\nOpen source projects thrive based on community support, and acknowledging contributors is a great way to maintain enthusiasm among the team. This can be done in the README, on social media, and in any other venue where you share your work (journal articles, conference presentations, etc).\nWhen acknowledging the people behind the code, be sure to describe how people contribute, including specific things they’ve done to move the project forward.\nHighlighting the roles of contributors coming from under-represented backgrounds may also help foster more inclusive developer communities, which is great for enhancing the quality of both communities and codebases.\n\n\nList your project in a community registry\nIt may be beneficial to include your project in a community registry to ensure that the work is findable and accessible by target audiences.\nArchaeologists may consider reaching out to open-archaeo.info, which is a list of open source software and resources developed by and for archaeologists. AncientMetagenomeDir is a similar resource specializing on tools developed in support of ancient DNA research.\nAdditionally, the archaeology CRAN task view lists numerous studies that include publicly accessible R code, which is a great resource for understanding how the community uses R in their research.\n\n\nPost about your work\nShare the cool things you make, and communicate the fact that anyone can use or adapt them! Even if the code is messy, it may inspire others to learn about your methods and extend upon what you’ve already done.\n\n\nPost contributor guidelines\nContributor guidelines inform prospective contributors about how they should engage with the codebase. They may include requests to focus on specific aspects of the project, and requirements to provide specific information in pull requests or issues. They may also outline the parameters through which code is vetted before being folded into the main branch.\nContributing guidelines are often specified in a CONTRIBUTING.md file. The Good Docs Project has written about the value of contributing guidelines, and has also provided a great template for you to adapt for your own project.\n\n\nPost a code of conduct\nA code of conduct demonstrates that you are able to foster a warm and welcoming community. They accomplish this by encouraging ethical and inclusive behaviour and by establishing parameters for a collaborative, respectful and safe work environment.\nA code of conduct also needs to be enforceable. It is therefore also necessary to include a response plan that outlines how incidents should be reported and documented, who will receive and handle these incidents, how incidents will be investigated and resolved, and how appeals and conflicts of interests will be handled.\nCodes of conduct are often specified in a CODE_OF_CONDUCT.md file. The Good Docs Project has written extensively about codes of conduct, and has also provided templates documents for codes of conduct, response plans, and means of documenting and investigating incidents.\n\n\nDonate to FOSS projects\nWhile many archaeologists who write code do benefit from a stable income, many do not. In fact, archaeologists who write code tend to be precariously employed. Even a small donation shows deep appreciation, and can help motivate labour performed largely by volunteers.\nIf you are able to provide financial support, please reach out to the maintainers of your most-used tools to help compensate them for their labour!\n\n\nPerform a code review\nYou may think, wait, is this something for a maintainathon? We say yes! Software reviews are valuable for people maintaining the software. It may give hints about what to improve and what to keep just as it is, as it works perfectly already. A review also raises awareness for the software, which is great for developers and potential users alike.\nThe Journal of Open Source Software is one such place to write about research software. They have a certain scope and focus on the developer side of things. If there is a smaller software package you would wish to review or you would like to focus on less technical details, other journals may be a better place. For example, Archäologische Informationen are happy to take software reviews (such as Thiery et al 2022).\nThis journal also published Recommendations for the review of archaeological research software, which might help you think of questions to ask yourself in regards to the software you are reviewing. Smaller reviews may also be a good topic for a blog or a social media post. Such appraisals are very valuable for researchers looking for the best solution to their problem!"
  },
  {
    "objectID": "resources.html#technical",
    "href": "resources.html#technical",
    "title": "Digital Archaeology Maintainathon",
    "section": "Technical",
    "text": "Technical\n\nTest your code’s functionality\nTesting your code involves including additional logic to test whether your code is operating as you expect it to. It is usually a good idea to write these unit tests before you write your code, and really think about what you want the outcome of each function or method to be. And then, as you write the function, test for that outcome as you iterate the development of that function. But often, in the excitement of working on a new project, we forget to test everything.\nWriting tests helps you save your code from yourself: If you change things later on, you can make sure that you still get the same results. For more complex projects, you will also want to add integration tests that check whether all the parts work together in the way that you want them to.\nGood tests help you make sure that your script, package, or software is maintainable and functional, and does exactly what you want it to. Also, tests are also great documentation! They tell others what you expected from your functions and methods, and help them get into working on your code.\nHere are some useful resources for learning how tests can benefit you, and how to write them:\n\nUnit Tests and Integration Tests - What’s the difference?\nThe package testthat in R and how to use it in package development.\nGetting Started With Testing in Python\n\nBe sure to also check the resources about Continuous Integration to see how you can automate your tests (and test your code on multiple operating systems)!\nAdding more tests is a great thing to do in a maintainathon! We invite you to follow this grear example:\n\n\nHow to write unit tests\n\n\nTake one function or method from a script, a package, a software that you produced.\nThink long and hard about what you actually wanted this to do.\nProduce some incoming test data, and some “ideal result” data.\nWrite at least one test that will make sure that one aspect of the result is really what you want it to be — and share that using #DigiArchMaintainathon!\n\nWhat do we mean by this? Let’s say you developed a revolutionary new function that calculates the mean of some numbers, in R:\nrevolutionary_new_mean &lt;- function(x) {\n  sum &lt;- sum(x)\n  n &lt;- length(x)\n\n  result &lt;- sum / n\n\n  return(result)\n}\nThink about what you want this result to be, and how your function could fail, and then see if it does or not:\ntest_that(\"revolutionary_new_mean returns the correct mean for numeric vectors\", {\n  # Test with a basic vector of integers\n  # Expected: (17 + 8 + 6 + 9) / 4 = 40 / 4 = 10\n  result &lt;- revolutionary_new_mean(c(17, 8, 6, 9))\n  expect_equal(result, 10)\n  \n  # Test with decimal numbers\n  # Expected: (17.5 + 8.5 + 6.5 + 9.5) / 4 = 42 / 4 = 10.5\n  result &lt;- my_mean(c(17.5, 8.5, 6.5, 9.5))\n  expect_equal(result, 10.5)\n})\n\ntest_that(\"revolutionary_new_mean handles non-numeric vectors\", {\n  # Expected: ???\n  result &lt;- revolutionary_new_mean(c(\"cake\", \"cheese\"))\n  # This is not valid R code.\n  expect_true(result, ????)\n})\nDone! We now wrote two unit tests (even though one of them will fail miserably).\n\n\n\nin progress: Optimizing for speed and efficiency\n\n\nin progress: Setup CI"
  },
  {
    "objectID": "resources.html#further-reading",
    "href": "resources.html#further-reading",
    "title": "Digital Archaeology Maintainathon",
    "section": "Further Reading",
    "text": "Further Reading\n\nResearch software engineering\nCoelho, J. and Valente, M.T. (2017) “Why modern open source projects fail,” in Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering. ESEC/FSE’17: Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, Paderborn Germany: ACM, pp. 186–196. Available at: https://doi.org/10.1145/3106237.3106246.\nIrving, D. et al. (2021) Research Software Engineering with Python. Available at: https://third-bit.com/py-rse/ (Accessed: January 2, 2026).\nNguyá»…n, S. and Rampin, V. (2022) “Who Writes Scholarly Code?,” International Journal of Digital Curation, 17(1), p. 18. Available at: https://doi.org/10.2218/ijdc.v17i1.839.\nRatto, M. (2007) “A Practice-Based Model of Access for Science: Linux Kernel Development and Shared Digital Resources,” Science & Technology Studies, 20(1), pp. 72–105. Available at: https://doi.org/10.23987/sts.55220.\nSholler, D. et al. (2019) “Ten Simple Rules for Helping Newcomers Become Contributors to Open Projects,” p. 11. Available at: https://doi.org/10.1371/journal.pcbi.1007296.\nTaschuk, M. and Wilson, G. (2017) “Ten simple rules for making research software more robust,” PLOS Computational Biology, 13(4), p. e1005412. Available at: https://doi.org/10.1371/journal.pcbi.1005412.\nWilson, G. et al. (2014) “Best Practices for Scientific Computing,” PLOS Biology, 12(1), p. e1001745. Available at: https://doi.org/10.1371/journal.pbio.1001745.\nWilson, G. et al. (2017) “Good enough practices in scientific computing,” PLOS Computational Biology, 13(6), p. e1005510. Available at: https://doi.org/10.1371/journal.pcbi.1005510.\n\n\nArchaeological software development\nBatist, Z. and Roe, J. (2024) “Open Archaeology, Open Source? Collaborative practices in an emerging community of archaeological software engineers,” Internet Archaeology [Preprint], (67). Available at: https://doi.org/10.11141/ia.67.13.\nBogdani, J. and Sciacca, F. (2020) “An introspective, incomplete, view on the activity of the FLOS community dealing with Archaeology and Cultural Heritage,” ARCHEO. FOSS XIV 2020, 15, p. 178.\nHomburg, T. et al. (2021) “Recommendations for the review of archaeological research software,” Archäologische Informationen, pp. 357-370 Seiten. Available at: https://doi.org/10.11588/AI.2020.1.81423.\nSchmidt, S.C. and Marwick, B. (2020) “Tool-driven revolutions in archaeological science,” Journal of Computer Applications in Archaeology, 3(1), pp. 18–32. Available at: https://doi.org/10.5334/jcaa.29.\nScollar, I. (1999) “25 Years of Computer Applications in Archaeology,” in L. Dingwall et al. (eds.) Archaeology in the Age of the Internet. Computer Applications and Quantitative Methods in Archaeology, Oxford: Archaeopress, pp. 5–10. Available at: https://proceedings.caaconference.org/paper/02_scollar_caa_1997/.\nWhallon, R. (1972) “The computer in archaeology: A critical survey,” Computers and the Humanities, 7(1), pp. 29–45. Available at: https://doi.org/10.1007/BF02403759.\nWilson, A.T. and Edwards, B. (eds.) (2015) Open Source Archaeology: Ethics and Practice. De Gruyter Open Poland. Available at: https://doi.org/10.1515/9783110440171.\n\n\nCulture and history of FOSS\nColeman, E.G. (2012) Coding Freedom: The Ethics and Aesthetics of Hacking. Princeton University Press. Available at: https://doi.org/10.1515/9781400845293.\nKelty, C.M. (2008) Two bits: The cultural significance of free software. Duke University Press.\nO’Neil, M. (2009) Cyberchiefs: Autonomy and authority in online tribes. London, UK: Pluto Press."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Digital Archaeology Maintainathon\n#DigiArchMaintainathon",
    "section": "",
    "text": "1.  Put in the work\n2.  Post about it\n3.  Reflect and discuss\n✓.  That’s it!\n\n\n\nSome things you can do to participate:\n\n\nAdd comments to old code or code in progress\nWrite a better README\nArchive your code in long-term repository\nDocument your research group’s coding guidelines\nAdd an open license\nAdd a citation file to your repo\nWrite some contributor guidelines\nDevelop a roadmap or checklist of things to do\nAcknowledge contributors\nMake a video demo of your code in action\nList your code in a community\nCleanup your working directories\nArchive abandoned projects\nVolunteer to review for the Journal of Open Source Software\nBrowse critical research on software development practices\nDonate to FOSS projects\n\n\n\nBrought to you by the Special Interest Group for Scientific Scripting Languages in Archaeology\nGot any questions or feedback? Join us in our Matrix chatroom or get in touch on Mastodon!"
  }
]