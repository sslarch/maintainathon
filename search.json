[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Documentation",
    "section": "",
    "text": "A README is a plaintext file that includes a detailed description of a project. It’s typically located in the root directory, and often includes:\n\nA broad overview of what the project does, why it was made, and the rationale behind the way it was implemented\nInstructions for how to install or run the code\nLinks to other related tools or resources\nRecognition of various contributors\nStatus updates, feature roadmaps, and an overview of the project’s overall orientation\n\nmakeareadme.com is a great resource that provides advice for writing clear and helpful readmes, including a template that you may adapt for your own purposes.\n\n\n\nCode comments appear as silent (i.e. non-functional) text embedded in the source code. They communicate what functions do by providing a brief description of how they are situated in broader workflows. They may also include notes and task lists for iteratively improving existing functions.\nSome qualities of good code comments include:\n\n\nClear and concise\nEasy to remove once a fix has been implemented\nExplain the “why”, not the “what”\nWritten for your future self\n\n\nHere is a great write-up about how to write effective code comments: How to Write Professional Code Comments: A Beginner’s Guide to Better Code Documentation (dev.to)\nHere’s a great example of code comments in action, adapted from the interpolate_curve.R function in Isak Roalkvam’s shoredate package:\n\n\nCode comments example\n\n# Interpolate displacement curve to a target location within the spatial\n#  coverage in south-eastern Norway\n#\n# Interpolate the trajectory of past shoreline displacement to a target\n#  location within the spatial coverage on the Skagerrak coast of south-eastern\n#  Norway. This based on the distance of the location to the shoreline isobases\n#  of the geologically derived displacement curves and is done using inverse\n#  distance weighting.\n\ninterpolate_curve &lt;- function(target,\n                              isobases = NA,\n                              power = 2,\n                              cal_reso = 10,\n                              verbose = FALSE){\n\n  # Load the spatial limit in south-eastern Norway\n  spatial_limit &lt;- sf::st_read(system.file(\"extdata/spatial_limit.gpkg\",\n                                           package = \"shoredate\"), quiet = TRUE)\n\n  # Check that the target location is set to correct CRS (causes error if it\n  # is not) and is located within the study area (prints warning if it is not)\n  if (is.na(sf::st_crs(target))) {\n    stop(\"Undefined coordinate reference system. This needs to be set to WGS84 / UTM zone 32N (EPSG: 32632).\")\n  }\n\n  if (sf::st_crs(target)$epsg != 32632) {\n    stop(paste0(\"Target has coordinate reference system with EPSG \",\n                sf::st_crs(target)$epsg,\n                \". This needs to be set to WGS84 / UTM zone 32N (EPSG: 32632).\"))\n  }\n\n  if (!(sf::st_intersects(target, spatial_limit, sparse = FALSE))) {\n    warning(paste(\"Target location is not within the study area for which the interpolation method was derived.\"))\n  }\n\n  # Load existing displacement curves\n  displacement_curves &lt;- get(load(system.file(\"extdata/displacement_curves.rda\",\n                  package = \"shoredate\",\n                  mustWork = TRUE)))\n\n  bce &lt;- seq(-1950, 10550,  cal_reso) * -1 # Sequence of years to match displacement data\n\n  # Use default isobases unless others are provided\n  if (any(is.na(isobases))) {\n    isobases &lt;- sf::st_read(\n                system.file(\"extdata/isobases.gpkg\",\n                  package = \"shoredate\",\n                  mustWork = TRUE), quiet = TRUE)\n  }\n\n  # If multiple displacement curves are to be returned due to multiple\n  # isobase directions, set up a list to be returned\n  if(length(unique(isobases$direction)) &gt; 1){\n    interpolated_curve &lt;- list()\n  }\n\n  for(i in 1:length(unique(isobases$direction))){\n    isobases_dir &lt;- isobases[isobases$direction ==\n                               unique(isobases$direction)[i], ]\n    dists &lt;- as.data.frame(sf::st_distance(target, isobases_dir))\n    names(dists) &lt;- isobases_dir$name\n\n    values &lt;- data.frame(matrix(ncol = 3, nrow = length(bce)))\n    names(values) &lt;- c(\"bce\", \"lowerelev\", \"upperelev\")\n\n    # In the case that a site is on the isobase of a\n    # displacement curve, simply return that displacement curve\n    if (any(as.numeric(dists) == 0)) {\n      values &lt;- displacement_curves[displacement_curves$name ==\n                                  names(dists)[which(as.numeric(dists) == 0)], ]\n\n    } else {\n      if (verbose) {\n        # If a site is not on a isobase, the displacement curve needs to be\n        # interpolated, in which case printing progress might be of interest\n        print(\"Interpolating displacement curve\")\n        pb &lt;- utils::txtProgressBar(min = 0,\n                                    max = length(bce),\n                                    style = 3,\n                                    char = \"=\")\n      }\n\n      for(j in 1:length(bce)){\n      for(k in 1:ncol(dists)){\n        le &lt;- displacement_curves[which(displacement_curves$name ==\n                                  names(dists)[k] & displacement_curves$bce ==\n                                  bce[j]), \"lowerelev\"]\n\n        ue &lt;- displacement_curves[which(displacement_curves$name ==\n                                  names(dists)[k] & displacement_curves$bce ==\n                                    bce[j]), \"upperelev\"]\n\n        dists[2, k] &lt;- le\n        dists[3, k] &lt;- ue\n      }\n      distdat &lt;- as.data.frame(t(dists))\n      names(distdat) &lt;- c(\"distance\", \"lower\", \"upper\")\n\n      # No sites are older than the lowest limit of any displacement curve\n      # so in case of NA values, simply assign NA\n      if (any(is.na(distdat))) {\n        lowerval &lt;- upperval &lt;- NA\n      } else {\n        # Inverse distance weighting\n        lowerval &lt;- sum(apply(distdat, 1,\n                              function(x) x[\"lower\"] * x[\"distance\"]^-power)) /\n          sum(apply(distdat, 1, function(x) x[\"distance\"] ^-power))\n        upperval &lt;- sum(apply(distdat, 1,\n                              function(x) x[\"upper\"] * x[\"distance\"]^-power)) /\n          sum(apply(distdat, 1, function(x) x[\"distance\"] ^-power))\n\n      }\n\n      values[j, 1:3] &lt;- c(bce[j], lowerval, upperval)\n\n      if (verbose) {\n        utils::setTxtProgressBar(pb, j)\n      }\n      }\n    }\n    if (verbose) {\n      close(pb)\n    }\n\n    values$direction &lt;- unique(isobases$direction)[i]\n    if (length(unique(isobases$direction)) &gt; 1) {\n      interpolated_curve[[i]] &lt;- values\n    } else {\n      interpolated_curve &lt;- values\n    }\n\n  }\n\n  interpolated_curve\n}\n\n\n\n\nA cff file is a plaintext file with .cff extension containing information that can be picked up by a reference manager to generate clean citations. It follows a yaml format, which is both human- and machine-readable.\nSee the example below from Maddison Simon’s and Sophie Schmidt’s Percopackage for some common information to include in your cff:\ncff-version: 1.2.0\nmessage: \"If you use this software, please cite it as below.\"\nauthors:\n  - family-names: Maddison\n    given-names: M. Simon\n    orcid: https://orcid.org/0000-0001-5006-6604\n  - family-names: Schmidt\n    given-names: Sophie C.\n    orcid: https://orcid.org/0000-0003-4696-2101\ntitle: \"Percopackage\"\nversion: 0.0.0.9001\nidentifiers:\n  - type: doi\n    value: 10.17605/OSF.IO/7EXTC\ndate-released: 2024-08-24\n\n\n\nWhen a README file is not enough, or if you want to host your code documentation on a separate website, you can use a documentation generator such as Sphinx. Sphinx is a tool that generates a series of HTML files (or PDF) starting from a directory containing reStructuredText or Markdown files.\nSphinx can be extended in various ways and it can power a whole website including other elements such as blog pages, homepages or books. However, it is primarily used to write documentation websites. To get a sense of what this looks like, look at many big documentation websites which are powered by Sphinx, such as the Python documentation and the Linux Kernel documentation. Other extensions allow using LaTeX scripts within the documentation files.\nSphinx can be set up easily: after installation it’s enough to run sphinx-quickstart from a project folder to create the necessary boilerplate to host the documentation. The documentation can then be extended in whatever way it is preferred. A particularly useful resource within Sphinx is autodoc, which can populate an API documentation page using docstrings from functions in the code.\nFor example, we can document a function within a code as (example from CodeRefinery lecture on documentation, DOI)\ndef multiply(a: float, b: float) -&gt; float:\n    \"\"\"\n    Multiply two numbers.\n\n    :param a: First number.\n    :param b: Second number.\n    :return: The product of a and b.\n    \"\"\"\n    return a * b\nWith Sphinx autodoc set up, the multiline comment would be pulled into an “API reference” section. This highlights the importance of writing documentation at the level of the code, and Sphinx allows to access documentation in a specific, well organized location. Because the resulting files are generally HTML, the documentation can then be hosted on a server as its own website, or as part of another website, such as a Github Pages webpage (as in Matteo Tomasini’s example on MetaPypulation (see the code here)).\nBecause the Sphinx documentation needs to be rebuilt after each change, it’s a good idea to automatize the process through the usage of Github Actions or other CI tools."
  },
  {
    "objectID": "resources.html#write-a-better-readme",
    "href": "resources.html#write-a-better-readme",
    "title": "Documentation",
    "section": "",
    "text": "A README is a plaintext file that includes a detailed description of a project. It’s typically located in the root directory, and often includes:\n\nA broad overview of what the project does, why it was made, and the rationale behind the way it was implemented\nInstructions for how to install or run the code\nLinks to other related tools or resources\nRecognition of various contributors\nStatus updates, feature roadmaps, and an overview of the project’s overall orientation\n\nmakeareadme.com is a great resource that provides advice for writing clear and helpful readmes, including a template that you may adapt for your own purposes."
  },
  {
    "objectID": "resources.html#code-comments",
    "href": "resources.html#code-comments",
    "title": "Documentation",
    "section": "",
    "text": "Code comments appear as silent (i.e. non-functional) text embedded in the source code. They communicate what functions do by providing a brief description of how they are situated in broader workflows. They may also include notes and task lists for iteratively improving existing functions.\nSome qualities of good code comments include:\n\n\nClear and concise\nEasy to remove once a fix has been implemented\nExplain the “why”, not the “what”\nWritten for your future self\n\n\nHere is a great write-up about how to write effective code comments: How to Write Professional Code Comments: A Beginner’s Guide to Better Code Documentation (dev.to)\nHere’s a great example of code comments in action, adapted from the interpolate_curve.R function in Isak Roalkvam’s shoredate package:\n\n\nCode comments example\n\n# Interpolate displacement curve to a target location within the spatial\n#  coverage in south-eastern Norway\n#\n# Interpolate the trajectory of past shoreline displacement to a target\n#  location within the spatial coverage on the Skagerrak coast of south-eastern\n#  Norway. This based on the distance of the location to the shoreline isobases\n#  of the geologically derived displacement curves and is done using inverse\n#  distance weighting.\n\ninterpolate_curve &lt;- function(target,\n                              isobases = NA,\n                              power = 2,\n                              cal_reso = 10,\n                              verbose = FALSE){\n\n  # Load the spatial limit in south-eastern Norway\n  spatial_limit &lt;- sf::st_read(system.file(\"extdata/spatial_limit.gpkg\",\n                                           package = \"shoredate\"), quiet = TRUE)\n\n  # Check that the target location is set to correct CRS (causes error if it\n  # is not) and is located within the study area (prints warning if it is not)\n  if (is.na(sf::st_crs(target))) {\n    stop(\"Undefined coordinate reference system. This needs to be set to WGS84 / UTM zone 32N (EPSG: 32632).\")\n  }\n\n  if (sf::st_crs(target)$epsg != 32632) {\n    stop(paste0(\"Target has coordinate reference system with EPSG \",\n                sf::st_crs(target)$epsg,\n                \". This needs to be set to WGS84 / UTM zone 32N (EPSG: 32632).\"))\n  }\n\n  if (!(sf::st_intersects(target, spatial_limit, sparse = FALSE))) {\n    warning(paste(\"Target location is not within the study area for which the interpolation method was derived.\"))\n  }\n\n  # Load existing displacement curves\n  displacement_curves &lt;- get(load(system.file(\"extdata/displacement_curves.rda\",\n                  package = \"shoredate\",\n                  mustWork = TRUE)))\n\n  bce &lt;- seq(-1950, 10550,  cal_reso) * -1 # Sequence of years to match displacement data\n\n  # Use default isobases unless others are provided\n  if (any(is.na(isobases))) {\n    isobases &lt;- sf::st_read(\n                system.file(\"extdata/isobases.gpkg\",\n                  package = \"shoredate\",\n                  mustWork = TRUE), quiet = TRUE)\n  }\n\n  # If multiple displacement curves are to be returned due to multiple\n  # isobase directions, set up a list to be returned\n  if(length(unique(isobases$direction)) &gt; 1){\n    interpolated_curve &lt;- list()\n  }\n\n  for(i in 1:length(unique(isobases$direction))){\n    isobases_dir &lt;- isobases[isobases$direction ==\n                               unique(isobases$direction)[i], ]\n    dists &lt;- as.data.frame(sf::st_distance(target, isobases_dir))\n    names(dists) &lt;- isobases_dir$name\n\n    values &lt;- data.frame(matrix(ncol = 3, nrow = length(bce)))\n    names(values) &lt;- c(\"bce\", \"lowerelev\", \"upperelev\")\n\n    # In the case that a site is on the isobase of a\n    # displacement curve, simply return that displacement curve\n    if (any(as.numeric(dists) == 0)) {\n      values &lt;- displacement_curves[displacement_curves$name ==\n                                  names(dists)[which(as.numeric(dists) == 0)], ]\n\n    } else {\n      if (verbose) {\n        # If a site is not on a isobase, the displacement curve needs to be\n        # interpolated, in which case printing progress might be of interest\n        print(\"Interpolating displacement curve\")\n        pb &lt;- utils::txtProgressBar(min = 0,\n                                    max = length(bce),\n                                    style = 3,\n                                    char = \"=\")\n      }\n\n      for(j in 1:length(bce)){\n      for(k in 1:ncol(dists)){\n        le &lt;- displacement_curves[which(displacement_curves$name ==\n                                  names(dists)[k] & displacement_curves$bce ==\n                                  bce[j]), \"lowerelev\"]\n\n        ue &lt;- displacement_curves[which(displacement_curves$name ==\n                                  names(dists)[k] & displacement_curves$bce ==\n                                    bce[j]), \"upperelev\"]\n\n        dists[2, k] &lt;- le\n        dists[3, k] &lt;- ue\n      }\n      distdat &lt;- as.data.frame(t(dists))\n      names(distdat) &lt;- c(\"distance\", \"lower\", \"upper\")\n\n      # No sites are older than the lowest limit of any displacement curve\n      # so in case of NA values, simply assign NA\n      if (any(is.na(distdat))) {\n        lowerval &lt;- upperval &lt;- NA\n      } else {\n        # Inverse distance weighting\n        lowerval &lt;- sum(apply(distdat, 1,\n                              function(x) x[\"lower\"] * x[\"distance\"]^-power)) /\n          sum(apply(distdat, 1, function(x) x[\"distance\"] ^-power))\n        upperval &lt;- sum(apply(distdat, 1,\n                              function(x) x[\"upper\"] * x[\"distance\"]^-power)) /\n          sum(apply(distdat, 1, function(x) x[\"distance\"] ^-power))\n\n      }\n\n      values[j, 1:3] &lt;- c(bce[j], lowerval, upperval)\n\n      if (verbose) {\n        utils::setTxtProgressBar(pb, j)\n      }\n      }\n    }\n    if (verbose) {\n      close(pb)\n    }\n\n    values$direction &lt;- unique(isobases$direction)[i]\n    if (length(unique(isobases$direction)) &gt; 1) {\n      interpolated_curve[[i]] &lt;- values\n    } else {\n      interpolated_curve &lt;- values\n    }\n\n  }\n\n  interpolated_curve\n}"
  },
  {
    "objectID": "resources.html#add-a-citation-file",
    "href": "resources.html#add-a-citation-file",
    "title": "Documentation",
    "section": "",
    "text": "A cff file is a plaintext file with .cff extension containing information that can be picked up by a reference manager to generate clean citations. It follows a yaml format, which is both human- and machine-readable.\nSee the example below from Maddison Simon’s and Sophie Schmidt’s Percopackage for some common information to include in your cff:\ncff-version: 1.2.0\nmessage: \"If you use this software, please cite it as below.\"\nauthors:\n  - family-names: Maddison\n    given-names: M. Simon\n    orcid: https://orcid.org/0000-0001-5006-6604\n  - family-names: Schmidt\n    given-names: Sophie C.\n    orcid: https://orcid.org/0000-0003-4696-2101\ntitle: \"Percopackage\"\nversion: 0.0.0.9001\nidentifiers:\n  - type: doi\n    value: 10.17605/OSF.IO/7EXTC\ndate-released: 2024-08-24"
  },
  {
    "objectID": "resources.html#writing-comprehensive-documentation",
    "href": "resources.html#writing-comprehensive-documentation",
    "title": "Documentation",
    "section": "",
    "text": "When a README file is not enough, or if you want to host your code documentation on a separate website, you can use a documentation generator such as Sphinx. Sphinx is a tool that generates a series of HTML files (or PDF) starting from a directory containing reStructuredText or Markdown files.\nSphinx can be extended in various ways and it can power a whole website including other elements such as blog pages, homepages or books. However, it is primarily used to write documentation websites. To get a sense of what this looks like, look at many big documentation websites which are powered by Sphinx, such as the Python documentation and the Linux Kernel documentation. Other extensions allow using LaTeX scripts within the documentation files.\nSphinx can be set up easily: after installation it’s enough to run sphinx-quickstart from a project folder to create the necessary boilerplate to host the documentation. The documentation can then be extended in whatever way it is preferred. A particularly useful resource within Sphinx is autodoc, which can populate an API documentation page using docstrings from functions in the code.\nFor example, we can document a function within a code as (example from CodeRefinery lecture on documentation, DOI)\ndef multiply(a: float, b: float) -&gt; float:\n    \"\"\"\n    Multiply two numbers.\n\n    :param a: First number.\n    :param b: Second number.\n    :return: The product of a and b.\n    \"\"\"\n    return a * b\nWith Sphinx autodoc set up, the multiline comment would be pulled into an “API reference” section. This highlights the importance of writing documentation at the level of the code, and Sphinx allows to access documentation in a specific, well organized location. Because the resulting files are generally HTML, the documentation can then be hosted on a server as its own website, or as part of another website, such as a Github Pages webpage (as in Matteo Tomasini’s example on MetaPypulation (see the code here)).\nBecause the Sphinx documentation needs to be rebuilt after each change, it’s a good idea to automatize the process through the usage of Github Actions or other CI tools."
  },
  {
    "objectID": "resources.html#archive-your-code-in-a-long-term-repository",
    "href": "resources.html#archive-your-code-in-a-long-term-repository",
    "title": "Documentation",
    "section": "Archive your code in a long-term repository",
    "text": "Archive your code in a long-term repository\nWhile commercial platforms like GitHub and GitLab may provide very useful collaboration features, they should not be trusted as long-term stewards of software or data. Professional archives should instead be used to backup public-facing code repositories.\nZenodo is a general-purpose open repository developed under the European OpenAIRE program and operated by CERN, which allows researchers to deposit research papers, data sets, research software, reports, and any other research related digital artefacts. One of its key features is direct integration with GitHub, and once configured, saves a snapshot of each release. For each submission, a persistent digital object identifier (DOI) is minted.\nSoftware Heritage is another archive dedicated to preserving publicly accessible code. It regularly crawls several software forges and package indexes, and anyone can upload their own repositories too."
  },
  {
    "objectID": "resources.html#archive-abandoned-projects",
    "href": "resources.html#archive-abandoned-projects",
    "title": "Documentation",
    "section": "Archive abandoned projects",
    "text": "Archive abandoned projects\nIt may be prudent to acknowledge when it’s time to tuck a project away and mark it as archived. This will put a banner on your repo and restrict any new pull requests.\nIf a project has been picked up by others, or the work continues in another forum, make sure to provide a link in the original README!"
  },
  {
    "objectID": "resources.html#develop-a-release-strategy",
    "href": "resources.html#develop-a-release-strategy",
    "title": "Documentation",
    "section": "Develop a release strategy",
    "text": "Develop a release strategy\nSharing code as a series of stable releases makes it easier to share code with predictable functionality. As new features are implemented or when the codebase changes in substantial ways, the software should be rolled into a new release. This enhances clarity for what users can expect when they download a specific release. It also makes it easier to communicate and de-bug issues raised by users by ensuring that all parties are accessing the same codebase.\nThere are numerous schemes for releasing code, which enable developers to communicate the degree of changes made between versions. Some of these include:\n\nSemantic Versioning: Major, Minor or Patch versions indicate breaking changes relative to prior versions.\nAlternative Versioning (AltVer): Tracks implementation of major overhauls, new features, and careful maintenance.\nCalendar Versioning (CalVer): For “rolling” releases that follow a regular maintenance cycle."
  },
  {
    "objectID": "resources.html#open-issues",
    "href": "resources.html#open-issues",
    "title": "Documentation",
    "section": "Open issues",
    "text": "Open issues\n\nOn other projects\nOn your own projects"
  },
  {
    "objectID": "resources.html#develop-a-project-roadmap",
    "href": "resources.html#develop-a-project-roadmap",
    "title": "Documentation",
    "section": "Develop a project roadmap",
    "text": "Develop a project roadmap\nIt may be helpful to develop a plan of action to structure future work. Some factors to consider include:\n\nWhat features are on the horizon?\nWhat steps need to be taken to achieve them?\nWhat resources will be needed to ensure effective action?\nWho can I call on for support?\n\nEffective roadmaps have tangible and measurable outcomes, and are comprised of tasks that can actually be acted upon. See this resource for some great tips on how to write great roadmaps."
  },
  {
    "objectID": "resources.html#add-a-license",
    "href": "resources.html#add-a-license",
    "title": "Documentation",
    "section": "Add a license",
    "text": "Add a license\nLicenses describe legal rights for accessing, using and modifying code. Open licenses, which enable widespread and uninhibited use, are increasingly common, however copyleft or opinionated licenses impose restrictions that add conditions based on specific use-cases. For instance, CC-NC limits reuse to non-commercial applications, copyleft forces downstream applications to adopt an equally permissive license for any derivative works, and numerous other licenses are aligned with specific social causes. The Hippocratic License hosts a tool for creating a custom license, including explicit allowances and restrictions for various potential use-cases, such as a Fossil Fuel Divestment module, a Law Enforcement module, and a Supply Chain Transparency module.\nVisit choosealicense.com for an extremely detailed survey and comparison of various software and non-software licenses. There is also a page describing what happens if you don’t choose a license.\nNote that software licenses are often distinct from licenses intended for non-software materials, such as data, media, documentation and fonts."
  },
  {
    "objectID": "resources.html#acknowledge-contributors",
    "href": "resources.html#acknowledge-contributors",
    "title": "Documentation",
    "section": "Acknowledge contributors",
    "text": "Acknowledge contributors\nOpen source projects thrive based on community support, and acknowledging contributors is a great way to maintain enthusiasm among the team. This can be done in the README, on social media, and in any other venue where you share your work (journal articles, conference presentations, etc).\nWhen acknowledging the people behind the code, be sure to describe how people contribute, including specific things they’ve done to move the project forward.\nHighlighting the roles of contributors coming from under-represented backgrounds may also help foster more inclusive developer communities, which is great for enhancing the quality of both communities and codebases."
  },
  {
    "objectID": "resources.html#list-your-project-in-a-community-registry",
    "href": "resources.html#list-your-project-in-a-community-registry",
    "title": "Documentation",
    "section": "List your project in a community registry",
    "text": "List your project in a community registry\nIt may be beneficial to include your project in a community registry to ensure that the work is findable and accessible by target audiences.\nArchaeologists may consider reaching out to open-archaeo.info, which is a list of open source software and resources developed by and for archaeologists. AncientMetagenomeDir is a similar resource specializing on tools developed in support of ancient DNA research.\nAdditionally, the archaeology CRAN task view lists numerous studies that include publicly accessible R code, which is a great resource for understanding how the community uses R in their research."
  },
  {
    "objectID": "resources.html#post-about-your-work",
    "href": "resources.html#post-about-your-work",
    "title": "Documentation",
    "section": "Post about your work",
    "text": "Post about your work\nShare the cool things you make, and communicate the fact that anyone can use or adapt them! Even if the code is messy, it may inspire others to learn about your methods and extend upon what you’ve already done."
  },
  {
    "objectID": "resources.html#post-contributor-guidelines",
    "href": "resources.html#post-contributor-guidelines",
    "title": "Documentation",
    "section": "Post contributor guidelines",
    "text": "Post contributor guidelines\nContributor guidelines inform prospective contributors about how they should engage with the codebase. They may include requests to focus on specific aspects of the project, and requirements to provide specific information in pull requests or issues. They may also outline the parameters through which code is vetted before being folded into the main branch.\nContributing guidelines are often specified in a CONTRIBUTING.md file. The Good Docs Project has written about the value of contributing guidelines, and has also provided a great template for you to adapt for your own project."
  },
  {
    "objectID": "resources.html#post-a-code-of-conduct",
    "href": "resources.html#post-a-code-of-conduct",
    "title": "Documentation",
    "section": "Post a code of conduct",
    "text": "Post a code of conduct\nA code of conduct demonstrates that you are able to foster a warm and welcoming community. They accomplish this by encouraging ethical and inclusive behaviour and by establishing parameters for a collaborative, respectful and safe work environment.\nA code of conduct also needs to be enforceable. It is therefore also necessary to include a response plan that outlines how incidents should be reported and documented, who will receive and handle these incidents, how incidents will be investigated and resolved, and how appeals and conflicts of interests will be handled.\nCodes of conduct are often specified in a CODE_OF_CONDUCT.md file. The Good Docs Project has written extensively about codes of conduct, and has also provided templates documents for codes of conduct, response plans, and means of documenting and investigating incidents."
  },
  {
    "objectID": "resources.html#donate-to-foss-projects",
    "href": "resources.html#donate-to-foss-projects",
    "title": "Documentation",
    "section": "Donate to FOSS projects",
    "text": "Donate to FOSS projects\nWhile many archaeologists who write code do benefit from a stable income, many do not. In fact, archaeologists who write code tend to be precariously employed. Even a small donation shows deep appreciation, and can help motivate labour performed largely by volunteers.\nIf you are able to provide financial support, please reach out to the maintainers of your most-used tools to help compensate them for their labour!"
  },
  {
    "objectID": "resources.html#perform-a-code-review",
    "href": "resources.html#perform-a-code-review",
    "title": "Documentation",
    "section": "Perform a code review",
    "text": "Perform a code review\nYou may think, wait, is this something for a maintainathon? We say yes! Software reviews are valuable for people maintaining the software. It may give hints about what to improve and what to keep just as it is, as it works perfectly already. A review also raises awareness for the software, which is great for developers and potential users alike.\nThe Journal of Open Source Software is one such place to write about research software. They have a certain scope and focus on the developer side of things. If there is a smaller software package you would wish to review or you would like to focus on less technical details, other journals may be a better place. For example, Archäologische Informationen are happy to take software reviews (such as Thiery et al 2022).\nThis journal also published Recommendations for the review of archaeological research software, which might help you think of questions to ask yourself in regards to the software you are reviewing. Smaller reviews may also be a good topic for a blog or a social media post. Such appraisals are very valuable for researchers looking for the best solution to their problem!"
  },
  {
    "objectID": "resources.html#test-your-codes-functionality",
    "href": "resources.html#test-your-codes-functionality",
    "title": "Documentation",
    "section": "Test your code’s functionality",
    "text": "Test your code’s functionality\nTesting your code involves including additional logic to test whether your code is operating as you expect it to. It is usually a good idea to write these unit tests before you write your code, and really think about what you want the outcome of each function or method to be. And then, as you write the function, test for that outcome as you iterate the development of that function. But often, in the excitement of working on a new project, we forget to test everything.\nWriting tests helps you save your code from yourself: If you change things later on, you can make sure that you still get the same results. For more complex projects, you will also want to add integration tests that check whether all the parts work together in the way that you want them to.\nGood tests help you make sure that your script, package, or software is maintainable and functional, and does exactly what you want it to. Also, tests are also great documentation! They tell others what you expected from your functions and methods, and help them get into working on your code.\nHere are some useful resources for learning how tests can benefit you, and how to write them:\n\nUnit Tests and Integration Tests - What’s the difference?\nThe package testthat in R and how to use it in package development.\nGetting Started With Testing in Python\n\nBe sure to also check the resources about Continuous Integration to see how you can automate your tests (and test your code on multiple operating systems)!\nAdding more tests is a great thing to do in a maintainathon! We invite you to follow this great example:\n\n\nHow to write unit tests\n\n\nTake one function or method from a script, a package, a software that you produced.\nThink long and hard about what you actually wanted this to do.\nProduce some incoming test data, and some “ideal result” data.\nWrite at least one test that will make sure that one aspect of the result is really what you want it to be — and share that using #DigiArchMaintainathon!\n\nWhat do we mean by this? Let’s say you developed a revolutionary new function that calculates the mean of some numbers, in R:\nrevolutionary_new_mean &lt;- function(x) {\n  sum &lt;- sum(x)\n  n &lt;- length(x)\n\n  result &lt;- sum / n\n\n  return(result)\n}\nThink about what you want this result to be, and how your function could fail, and then see if it does or not:\ntest_that(\"revolutionary_new_mean returns the correct mean for numeric vectors\", {\n  # Test with a basic vector of integers\n  # Expected: (17 + 8 + 6 + 9) / 4 = 40 / 4 = 10\n  result &lt;- revolutionary_new_mean(c(17, 8, 6, 9))\n  expect_equal(result, 10)\n  \n  # Test with decimal numbers\n  # Expected: (17.5 + 8.5 + 6.5 + 9.5) / 4 = 42 / 4 = 10.5\n  result &lt;- my_mean(c(17.5, 8.5, 6.5, 9.5))\n  expect_equal(result, 10.5)\n})\n\ntest_that(\"revolutionary_new_mean handles non-numeric vectors\", {\n  # Expected: ???\n  result &lt;- revolutionary_new_mean(c(\"cake\", \"cheese\"))\n  # This is not valid R code.\n  expect_true(result, ????)\n})\nDone! We now wrote two unit tests (even though one of them will fail miserably)."
  },
  {
    "objectID": "resources.html#optimizing-for-speed-and-efficiency",
    "href": "resources.html#optimizing-for-speed-and-efficiency",
    "title": "Documentation",
    "section": "Optimizing for speed and efficiency",
    "text": "Optimizing for speed and efficiency"
  },
  {
    "objectID": "resources.html#setup-continuous-integration",
    "href": "resources.html#setup-continuous-integration",
    "title": "Documentation",
    "section": "Setup Continuous Integration",
    "text": "Setup Continuous Integration\nContinuous integration (CI) refers to the process of automating tasks pertaining to the integration of changes and new features into existing software. The automatization process can be setup for different tasks such as building a software, testing, generating documentation, etc. There are several CI tools that can be used, one of the most accessible is Github Actions (but do check out GitLab CI if you work on Gitlab).\nGithub Actions come in different flavors and can do many different things: for example, if you have setup a website using Github Pages, Github runs actions “under the hood” to build the website after each change committed. But Github Actions can be set-up for our own projects too. There is a whole marketplace of actions to choose from.\nTo set up an automatic Github action, one needs to go in the repository of the project and click on Actions, then click on “New Workflow”.\n\nThen, select the action you would like to set up. For example to set up automated testing on a Python software, you would choose “Python Application”.\n\nThis will create a yaml script in the .github/workflows folder, that can be modified to correspond to one’s own needs. For example, in the following file, the Github Action will perform three actions:\n# This workflow will install Python dependencies, run tests and lint with a single version of Python\n# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-python\n\nname: Python application\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\npermissions:\n  contents: read\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n    - name: Set up Python 3.12\n1      uses: actions/setup-python@v3\n      with:\n        python-version: \"3.12\"\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install flake8 pytest pytest-cov\n        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi\n    - name: Lint with flake8\n      run: |\n        # stop the build if there are Python syntax errors or undefined names \n2        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics\n        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide\n        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics\n    - name: Test with pytest and calculate coverage\n      run: |\n3        pytest --cov-report \"xml:coverage.xml\" --cov=.\n    - name: Create coverage\n      if: ${{ github.event_name == 'pull_request' }}\n      uses: orgoro/coverage@v3\n      with: \n        coverageFile: coverage.xml\n        token: ${{ secrets.GITHUB_TOKEN }}\n\n1\n\nsetting up the Python version and installing the dependencies to run the Python application (necessitates a requirements.txt file in the directory),\n\n2\n\nlinting\n\n3\n\ntesting using the functions defined by the user – this last action also generates a test coverage report.\n\n\nIn another example, the following action is set up to deploy the documentation generated with Sphinx on the user’s Github Pages instance.\nname: example\n\non: [push, pull_request, workflow_dispatch]\n\npermissions:\n  contents: write\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v5\n      - name: Install dependencies\n        run: |\n          pip install sphinx myst_parser\n          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi\n      - name: Sphinx build\n        run: |\n          sphinx-apidoc -o ./docs/source ./metapypulation\n          sphinx-build ./docs/source build/\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v4\n        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}\n        with:\n          publish_branch: gh-pages\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: build/\n          force_orphan: true\nHowever you want to use CI, it is invaluable. After setting up an action for automated testing, for example, after each commit and push to the Github repository, you will get a notification of failed tests, or successful deployment, or whatever action you have set up for your project."
  },
  {
    "objectID": "resources.html#research-software-engineering",
    "href": "resources.html#research-software-engineering",
    "title": "Documentation",
    "section": "Research software engineering",
    "text": "Research software engineering\nBast, R. et al. (2023) “How to document your research software - CodeRefinery lesson”. Available at: https://zenodo.org/records/8280235 (Accessed: January 7, 2026).\nBast, R. et al. (2025) “Automated testing - CodeRefinery lesson”. Available at: https://zenodo.org/records/16410888 (Accessed: January 7, 2026)\nCoelho, J. and Valente, M.T. (2017) “Why modern open source projects fail,” in Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering. ESEC/FSE’17: Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, Paderborn Germany: ACM, pp. 186–196. Available at: https://doi.org/10.1145/3106237.3106246.\nIrving, D. et al. (2021) Research Software Engineering with Python. Available at: https://third-bit.com/py-rse/ (Accessed: January 2, 2026).\nNguyá»…n, S. and Rampin, V. (2022) “Who Writes Scholarly Code?,” International Journal of Digital Curation, 17(1), p. 18. Available at: https://doi.org/10.2218/ijdc.v17i1.839.\nRatto, M. (2007) “A Practice-Based Model of Access for Science: Linux Kernel Development and Shared Digital Resources,” Science & Technology Studies, 20(1), pp. 72–105. Available at: https://doi.org/10.23987/sts.55220.\nSholler, D. et al. (2019) “Ten Simple Rules for Helping Newcomers Become Contributors to Open Projects,” p. 11. Available at: https://doi.org/10.1371/journal.pcbi.1007296.\nTaschuk, M. and Wilson, G. (2017) “Ten simple rules for making research software more robust,” PLOS Computational Biology, 13(4), p. e1005412. Available at: https://doi.org/10.1371/journal.pcbi.1005412.\nWilson, G. et al. (2014) “Best Practices for Scientific Computing,” PLOS Biology, 12(1), p. e1001745. Available at: https://doi.org/10.1371/journal.pbio.1001745.\nWilson, G. et al. (2017) “Good enough practices in scientific computing,” PLOS Computational Biology, 13(6), p. e1005510. Available at: https://doi.org/10.1371/journal.pcbi.1005510."
  },
  {
    "objectID": "resources.html#archaeological-software-development",
    "href": "resources.html#archaeological-software-development",
    "title": "Documentation",
    "section": "Archaeological software development",
    "text": "Archaeological software development\nBatist, Z. and Roe, J. (2024) “Open Archaeology, Open Source? Collaborative practices in an emerging community of archaeological software engineers,” Internet Archaeology [Preprint], (67). Available at: https://doi.org/10.11141/ia.67.13.\nBogdani, J. and Sciacca, F. (2020) “An introspective, incomplete, view on the activity of the FLOS community dealing with Archaeology and Cultural Heritage,” ARCHEO. FOSS XIV 2020, 15, p. 178.\nHomburg, T. et al. (2021) “Recommendations for the review of archaeological research software,” Archäologische Informationen, pp. 357-370 Seiten. Available at: https://doi.org/10.11588/AI.2020.1.81423.\nSchmidt, S.C. and Marwick, B. (2020) “Tool-driven revolutions in archaeological science,” Journal of Computer Applications in Archaeology, 3(1), pp. 18–32. Available at: https://doi.org/10.5334/jcaa.29.\nScollar, I. (1999) “25 Years of Computer Applications in Archaeology,” in L. Dingwall et al. (eds.) Archaeology in the Age of the Internet. Computer Applications and Quantitative Methods in Archaeology, Oxford: Archaeopress, pp. 5–10. Available at: https://proceedings.caaconference.org/paper/02_scollar_caa_1997/.\nWhallon, R. (1972) “The computer in archaeology: A critical survey,” Computers and the Humanities, 7(1), pp. 29–45. Available at: https://doi.org/10.1007/BF02403759.\nWilson, A.T. and Edwards, B. (eds.) (2015) Open Source Archaeology: Ethics and Practice. De Gruyter Open Poland. Available at: https://doi.org/10.1515/9783110440171."
  },
  {
    "objectID": "resources.html#culture-and-history-of-foss",
    "href": "resources.html#culture-and-history-of-foss",
    "title": "Documentation",
    "section": "Culture and history of FOSS",
    "text": "Culture and history of FOSS\nColeman, E.G. (2012) Coding Freedom: The Ethics and Aesthetics of Hacking. Princeton University Press. Available at: https://doi.org/10.1515/9781400845293.\nKelty, C.M. (2008) Two bits: The cultural significance of free software. Duke University Press.\nO’Neil, M. (2009) Cyberchiefs: Autonomy and authority in online tribes. London, UK: Pluto Press."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Digital Archaeology Maintainathon\n#DigiArchMaintainathon",
    "section": "",
    "text": "1.  Put in the work\n2.  Post about it\n3.  Reflect and discuss\n✓.  That’s it!\n\n\n\nSome things you can do to participate:\n\n\nAdd comments to old code or code in progress\nWrite a better README\nArchive your code in long-term repository\nDocument your research group’s coding guidelines\nAdd an open license\nAdd a citation file to your repo\nWrite some contributor guidelines\nDevelop a roadmap or checklist of things to do\nAcknowledge contributors\nMake a video demo of your code in action\nList your code in a community\nCleanup your working directories\nArchive abandoned projects\nVolunteer to review for the Journal of Open Source Software\nBrowse critical research on software development practices\nDonate to FOSS projects\n\n\n\nBrought to you by the Special Interest Group for Scientific Scripting Languages in Archaeology\nGot any questions or feedback? Join us in our Matrix chatroom or get in touch on Mastodon!"
  }
]